// @ts-check
import { formatNumberLocale } from './_env.js';
import factors from './factors.js';
import contingency from './contingency.js';
import numeric from './numeric.js';
import variants from './variants.js';
import { getBinaryLabels, getDefaultMissingLabel, getTableHeaders, normalizeLanguage, translate } from '../i18n/index.js';

/**
 * @typedef {Object} Column
 * @property {string} col_hash
 * @property {string} col_label
 * @property {'q'|'n'|'l'} col_type
 * @property {string=} col_sep
 * @property {any[]=} raw_values
 * @property {{labels?: string[]}=} col_values
 */

/**
 * @typedef {{columns: string[], rows: Array<Record<string,string>>, [k:string]: any}} TableLike
 */

/**
 * @typedef {{analysis: Array<{ predictor: string, response?: string|null, predictor_type: string, response_type?: string|null, table: TableLike }>, test_legend: Array<{method:string,symbol:string}>}} CombinedAnalysis
 */

/** @type {Record<string, any>} */
const ns = {};

/**
 * Retrieve a column by hash from a parsed database payload.
 * @param {{columns?: Column[]}|null|undefined} database
 * @param {string} colHash
 * @returns {Column|null}
 */
ns.getColumn = function (database, colHash) {
  if (!database || !Array.isArray(database.columns)) return null;
  return database.columns.find((col) => col?.col_hash === colHash) ?? null;
};

/**
 * Retrieve a column by hash and decode its raw values.
 * @param {{columns?: Column[]}|null|undefined} database Parsed database payload returned by parseColumns
 * @param {string} colHash Column hash to match
 * @param {number|null} [variantIndex=null] Optional variant index from col_vars
 * @returns {{ column: Column|null, variant: any|null, rawValues: any[] }}
 */
ns.getColumnValues = function (database, colHash, variantIndex = null) {
  const column = ns.getColumn(database, colHash);
  if (!column) {
    return { column: null, variant: null, rawValues: [] };
  }
  const hasVariantIndex = variantIndex !== null && variantIndex !== undefined;
  const variant = hasVariantIndex && Array.isArray(column.col_vars)
    ? column.col_vars[variantIndex] ?? null
    : null;
  const colType = variant?.col_type ?? column.col_type ?? 'q';
  let colSep = variant?.col_sep ?? column.col_sep;
  if (!colSep) colSep = colType === 'l' ? ';' : '';
  const colValues = variant?.col_values ?? column.col_values;
  const target = variant
    ? { ...variant, col_type: colType, col_sep: colSep, col_values: colValues }
    : { ...column, col_type: colType, col_sep: colSep, col_values: colValues };
  const rawValues = factors.decodeColumn(target) || [];
  return { column, variant, rawValues };
};

/**
 * Append a variant to the specified column, seeding the base variant when needed.
 * @param {{columns?: Column[]}|null|undefined} database Parsed database payload returned by parseColumns
 * @param {string} colHash Column hash to match
 * @param {any} newVariant Variant payload generated by variants.createVariant
 * @returns {any}
 */
ns.addVariant = function (database, colHash, newVariant) {
  if (!newVariant || typeof newVariant !== 'object') {
    throw new Error('Variant payload is required to add a variant.');
  }
  if (!database || !Array.isArray(database.columns)) {
    throw new Error('Invalid database payload; expected an object with columns.');
  }
  const column = ns.getColumn(database, colHash);
  if (!column) {
    throw new Error(`Column with hash ${colHash} not found in database.`);
  }
  if (!Array.isArray(column.col_vars) || column.col_vars.length === 0) {
    const colLabel = column.col_label ?? "Original";
    const colType = column.col_type ?? 'q';
    const colSep = column.col_sep ?? (colType === 'l' ? ';' : '');
    const clone = variants.cloneColValues
      ? variants.cloneColValues(column.col_values)
      : (column.col_values ? JSON.parse(JSON.stringify(column.col_values)) : column.col_values);
    column.col_vars = [{
      var_label: colLabel,
      col_type: colType,
      col_sep: colSep,
      col_values: clone,
      meta: { kind: 'original' }
    }];
  }
  column.col_vars.push(newVariant);
  return newVariant;
};

/**
 * Build row-wise objects from column-major raw_values.
 * @param {Column[]} columns
 * @returns {Array<Record<string, any>>}
 */
ns.getRowwiseData = function (columns) {
  if (!Array.isArray(columns)) return [];
  const n = Math.max(...columns.map(c => c.raw_values?.length || 0));
  const rows = [];
  for (let i = 0; i < n; i++) { const row = {}; columns.forEach(col => { row[col.col_hash] = col.raw_values?.[i] ?? null; }); rows.push(row); }
  return rows;
};

/**
 * Convert named-row objects into a 2D matrix following provided column order.
 * @param {string[]} columns
 * @param {Array<Record<string, any>>} rows
 * @returns {any[][]}
 */
ns.tabularRowsToMatrix = function (columns, rows) { return rows.map(row => columns.map(col => row[col])); };

/**
 * Frequency table for qualitative values.
 * @param {Array<string|null|undefined>} values
 * @param {(ctx:{count:number,percent:number,total:number})=>string=} formatFn
 * @param {{missing_label?:string, include_missing?:boolean, lang?:string}=} options
 * @param {{labels?: string[]|null}=} param3
 * @returns {TableLike}
 */
ns.summarize_q = function (values, formatFn = null, options = {}, { labels = null } = {}) {
  const freqMap = {}; let missingCount = 0; const total = values.length;
  const lang = normalizeLanguage(options?.lang);
  const missingLabel = options?.missing_label ?? getDefaultMissingLabel(lang);
  const includeMissing = options?.include_missing ?? true;
  const [variableHeader, descriptionHeader] = getTableHeaders(lang);
  values.forEach(val => { const v = val?.toString().trim(); if (!v) { missingCount++; return; } freqMap[v] = (freqMap[v] || 0) + 1; });
  const sortedLabels = labels ?? Object.keys(freqMap).sort();
  const rows = sortedLabels.map(label => { const count = freqMap[label] || 0; const percent = (count / total) * 100; const percentFormatted = formatNumberLocale(percent, 1, lang); const cell = formatFn ? formatFn({ count, percent, total }) : `${count} (${percentFormatted}%)`; return { [variableHeader]: label, [descriptionHeader]: cell }; });
  if (includeMissing && missingCount > 0) { const percent = (missingCount / total) * 100; const percentFormatted = formatNumberLocale(percent, 1, lang); const cell = formatFn ? formatFn({ count: missingCount, percent, total }) : `${missingCount} (${percentFormatted}%)`; rows.push({ [variableHeader]: missingLabel, [descriptionHeader]: cell }); }
  return { columns: [variableHeader, descriptionHeader], rows, summary: { total, total_is_full: true }, lang };
};

/**
 * Frequency table for list-like qualitative values (split by a separator).
 * @param {Array<string|null|undefined>} values
 * @param {string=} sep
 * @param {(ctx:{count:number,percent:number,total:number})=>string=} formatFn
 * @param {{missing_label?: string, include_missing?: boolean, lang?: string}=} options
 * @returns {TableLike}
 */
ns.summarize_l = function (values, sep = ';', formatFn = null, options = {}) {
  if (!Array.isArray(values)) return { columns: [], rows: [], summary: { total: 0, total_is_full: true } };
  const counts = {}; let missingCount = 0; const total = values.length;
  const lang = normalizeLanguage(options?.lang);
  const missingLabel = options?.missing_label ?? getDefaultMissingLabel(lang);
  const includeMissing = options?.include_missing ?? true;
  const [variableHeader, descriptionHeader] = getTableHeaders(lang);
  values.forEach(v => { if (!v?.trim()) { missingCount++; return; } const items = v.split(sep).map(s => s.trim()).filter(Boolean); if (items.length === 0) { missingCount++; return; } items.forEach(item => { counts[item] = (counts[item] || 0) + 1; }); });
  const rows = Object.entries(counts).sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0])).map(([level, count]) => { const percent = (count / total) * 100; const percentFormatted = formatNumberLocale(percent, 1, lang); const cell = formatFn ? formatFn({ count, percent, total }) : `${count} (${percentFormatted}%)`; return { [variableHeader]: level, [descriptionHeader]: cell }; });
  if (includeMissing && missingCount > 0) { const percent = (missingCount / total) * 100; const percentFormatted = formatNumberLocale(percent, 1, lang); const cell = formatFn ? formatFn({ count: missingCount, percent, total }) : `${missingCount} (${percentFormatted}%)`; rows.push({ [variableHeader]: missingLabel, [descriptionHeader]: cell }); }
  return { columns: [variableHeader, descriptionHeader], rows, summary: { total, total_is_full: true }, lang };
};

/**
 * Expand list-like predictors into binary yes/no columns and summarize against qualitative responses.
 * Returns one chi-square table per list item.
 * @param {Array<string|null|undefined>} listValues
 * @param {string[]} responseVals
 * @param {(ctx:{count:number,percent:number,rowTotal:number,colTotal:number})=>string=} formatFn
 * @param {{lang?:string}=} options
 * @param {{separator?:string,predictorLabel?:string|null,responseLabel?:string|null,lang?:string}=} meta
 * @returns {Array<{label:string,predictor_label?:string|null,predictor_label_stripped?:string|null,response_label?:string|null,table:TableLike}>}
 */
ns.summarize_l_q = function (listValues, responseVals, formatFn = null, options = {}, meta = {}) {
  const separator = meta?.separator ?? ';';
  const predictorLabel = meta?.predictorLabel ?? null;
  const responseLabel = meta?.responseLabel ?? null;
  const lang = normalizeLanguage(meta?.lang ?? options?.lang);
  const includePrefix = meta?.includePrefix ?? true;
  const cleanedPredictor = predictorLabel ? predictorLabel.replace(/[\s\p{P}]+$/u, '') : predictorLabel;
  const { columns: binaryColumns = {} } = numeric.decomposeListAsBinaryCols(listValues, separator, options);
  const results = [];
  Object.entries(binaryColumns).forEach(([label, binVals]) => {
    try {
      const table = contingency.summarize_q_q(binVals, responseVals, formatFn, options);
      const displayLabel = includePrefix && (cleanedPredictor || predictorLabel)
        ? `${cleanedPredictor || predictorLabel}: ${label}`
        : label;
      results.push({
        label,
        display_label: displayLabel,
        predictor_label: predictorLabel,
        predictor_label_stripped: cleanedPredictor,
        response_label: responseLabel,
        table
      });
    } catch (e) {
      const warnMessage = translate('warnings.summarizeFailure', lang, { label, context: predictorLabel ?? '' });
      console.warn(`${warnMessage}:`, e.message);
    }
  });
  return results;
};

/**
 * Build a map of statistical test methods to display symbols.
 * @param {string[]} methods
 * @param {{symbol_style?: 'numeric'|'alpha'}=} options
 * @returns {Record<string,string>}
 */
ns.generateTestSymbolMap = function (methods, options) {
  const style = options?.symbol_style ?? 'numeric'; const uniqueMethods = [...new Set(methods)];
  const numericSym = ['¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹', '¹⁰']; const alpha = ['ᵃ', 'ᵇ', 'ᶜ', 'ᵈ', 'ᵉ', 'ᶠ', 'ᵍ', 'ʰ', 'ᶦ', 'ʲ'];
  const base = (style === 'alpha' ? alpha : numericSym); const map = {}; uniqueMethods.forEach((method, i) => { map[method] = base[i] || `(${i + 1})`; }); return map;
};


/**
 * Merge caller options with the defaults that Statz uses during runAnalysis.
 * @param {Record<string, any>=} options
 * @returns {Record<string, any>}
 */
ns.getDefaultAnalysisOptions = function (options = {}) {
  const lang = normalizeLanguage(options?.lang);
  const normalized = { ...options, lang };

  const alphaValue = Number(normalized.alpha);
  normalized.symbol_style = normalized.symbol_style ?? 'numeric';
  normalized.alpha = Number.isFinite(alphaValue) ? alphaValue : 0.05;

  const numericStats = Array.isArray(normalized.stat_options_numeric) && normalized.stat_options_numeric.length
    ? normalized.stat_options_numeric.slice()
    : ['min', 'max', 'mean_sd', 'n_missing'];
  normalized.stat_options_numeric = numericStats;

  const groupedStats = Array.isArray(normalized.stat_options_by_group) && normalized.stat_options_by_group.length
    ? normalized.stat_options_by_group.slice()
    : ['mean_sd'];
  normalized.stat_options_by_group = groupedStats;

  const statOptions = Array.isArray(normalized.stat_options) && normalized.stat_options.length
    ? normalized.stat_options.slice()
    : groupedStats.slice();
  normalized.stat_options = statOptions;

  normalized.percent_by = normalized.percent_by === 'col' ? 'col' : 'row';
  normalized.adjust_kruskal = normalized.adjust_kruskal ?? 'bonferroni';
  normalized.include_missing = normalized.include_missing ?? true;
  normalized.label_list_with_column = normalized.label_list_with_column ?? true;
  normalized.with_residuals = normalized.with_residuals ?? true;
  normalized.missing_label = normalized.missing_label ?? getDefaultMissingLabel(lang);

  const residuals = normalized.residual_symbols ?? {};
  normalized.residual_symbols = {
    greater: residuals.greater ?? translate('table.legends.residualGreaterSymbol', lang),
    lower: residuals.lower ?? translate('table.legends.residualLowerSymbol', lang)
  };

  const binaryLabels = getBinaryLabels(lang);
  normalized.yes_label = normalized.yes_label ?? binaryLabels.yes;
  normalized.no_label = normalized.no_label ?? binaryLabels.no;

  const minCount = Number(normalized.binary_min_count);
  normalized.binary_min_count = Number.isFinite(minCount) && minCount > 0 ? Math.floor(minCount) : 1;

  return normalized;
};

/**
 * Replace col_label in a list of column payloads with the label from the source database.
 * Accepts either JSON strings or plain objects and returns JSON strings (so Bubble can store them).
 * @param {Array<string|Record<string, any>>} columnPayloads
 * @param {Record<string,{columns:any[]}>} dbs
 * @returns {string[]} Updated payloads as JSON strings
 */
ns.updateColumnLabelsFromDb = function (columnPayloads, dbs) {
  if (!Array.isArray(columnPayloads)) return [];
  return columnPayloads.map((entry) => {
    let col;
    if (typeof entry === 'string') {
      try { col = JSON.parse(entry); } catch { return null; }
    } else if (entry && typeof entry === 'object') {
      col = { ...entry };
    } else {
      return null;
    }
    if (!col.database_id || !col.col_hash) return null;
    const db = dbs?.[col.database_id];
    if (!db) return null;
    const baseCol = ns.getColumn(db, col.col_hash);
    if (!baseCol) return null;
    const hasVariantIndex = col.col_var_index !== null && col.col_var_index !== undefined;
    const variant = hasVariantIndex && Array.isArray(baseCol.col_vars) ? baseCol.col_vars[col.col_var_index] : null;
    const label = variant?.var_label || baseCol.col_label || col.col_label || '';
    return JSON.stringify({ ...col, col_label: label });
  }).filter(Boolean);
};

const normalizeHeaderForMatch = (label) => String(label ?? '')
  .toLowerCase()
  .replace(/[^a-z0-9]+/g, '')
  .trim();

/**
 * Suggest mappings between new columns and existing columns for a Bubble RG.
 * Returns objects ready to JSON.stringify for the RG data source.
 * @param {{columns?: any[]}} oldDb
 * @param {{columns?: any[]}} newDb
 * @param {Array<string|{new_hash:string,new_label?:string,new_type?:string,choice?:string,suggested_choice?:string}>} [existingMappings]
 * @returns {{ mappings: string[], warnings: string[], errors: string[] }}
 */
ns.buildColumnMappingSuggestions = function (oldDb, newDb, existingMappings = null) {
  const oldCols = Array.isArray(oldDb?.columns) ? oldDb.columns : [];
  const newCols = Array.isArray(newDb?.columns) ? newDb.columns : [];
  const warnings = [];
  const errors = [];
  const lang = normalizeLanguage(newDb?.lang ?? oldDb?.lang);
  const oldByHash = new Map(oldCols.map(c => [c.col_hash, c]));
  const oldByNorm = new Map();
  oldCols.forEach((col) => {
    const norm = normalizeHeaderForMatch(col.col_label ?? col.col_name ?? col.col_hash ?? '');
    if (!norm) return;
    if (!oldByNorm.has(norm)) oldByNorm.set(norm, []);
    oldByNorm.get(norm).push(col);
  });

  const existingMap = new Map(
    (Array.isArray(existingMappings) ? existingMappings : []).map((m) => {
      if (typeof m === 'string') {
        try { m = JSON.parse(m); } catch { return null; }
      }
      if (!m || !m.new_hash) return null;
      return [m.new_hash, m.choice ?? m.suggested_choice];
    }).filter(Boolean)
  );

  const mappings = newCols.map((col) => {
    const norm = normalizeHeaderForMatch(col.col_label ?? col.col_name ?? col.col_hash ?? '');
    let suggested_choice = 'NEW';
    const hasManual = existingMap.has(col.col_hash);
    const manualChoice = hasManual ? existingMap.get(col.col_hash) : undefined;

    if (hasManual) {
      suggested_choice = manualChoice ?? '';
      if (manualChoice && manualChoice !== 'NEW' && manualChoice !== 'IGNORE' && !oldByHash.has(manualChoice)) {
        errors.push(translate('mapping.invalid', lang, { label: col.col_label ?? col.col_name ?? col.col_hash }));
      }
    } else if (oldByHash.has(col.col_hash)) {
      // Same hash exists in old DB; prefer it directly
      suggested_choice = col.col_hash;
    } else if (norm && oldByNorm.has(norm)) {
      const candidates = oldByNorm.get(norm);
      if (candidates.length === 1) {
        suggested_choice = candidates[0].col_hash;
      } else {
        errors.push(translate('mapping.multiple', lang, { label: col.col_label ?? col.col_name ?? col.col_hash }));
      }
    } else {
      warnings.push(translate('mapping.nomatch', lang, { label: col.col_label ?? col.col_name ?? col.col_hash }));
    }
    return JSON.stringify({
      new_hash: col.col_hash,
      new_label: col.col_label ?? col.col_name ?? col.col_hash,
      new_type: col.col_type ?? 'q',
      suggested_choice
    });
  });

  const mappedOld = new Set(
    mappings.map((m) => {
      try { m = JSON.parse(m); } catch { return null; }
      const choice = m.choice ?? m.suggested_choice;
      return choice && choice !== 'NEW' && choice !== 'IGNORE' ? choice : null;
    }).filter(Boolean)
  );
  const choiceCounts = new Map();
  mappings.forEach((m) => {
    try { m = JSON.parse(m); } catch { return; }
    const choice = m.choice ?? m.suggested_choice;
    if (!choice || choice === 'NEW' || choice === 'IGNORE') return;
    choiceCounts.set(choice, (choiceCounts.get(choice) || 0) + 1);
  });
  choiceCounts.forEach((count, choice) => {
    if (count > 1) {
      const label = (oldByHash.get(choice)?.col_label ?? oldByHash.get(choice)?.col_name ?? choice);
      errors.push(translate('mapping.multiple', lang, { label }));
    }
  });

  oldCols.forEach((col) => {
    if (!mappedOld.has(col.col_hash)) {
      warnings.push(translate('mapping.old_dropped', lang, { label: col.col_label ?? col.col_name ?? col.col_hash }));
    }
  });

  return { mappings, warnings, errors };
};

/**
 * Apply confirmed mappings to produce a new DB payload.
 * @param {{columns?: any[]}} oldDb
 * @param {{columns?: any[]}} newDb
 * @param {Array<string|{new_hash:string,new_label:string,choice:string}>} mappingEntries
 * @returns {Record<string, any>}
 */
ns.applyColumnMappings = function (oldDb, newDb, mappingEntries) {
  const oldCols = Array.isArray(oldDb?.columns) ? oldDb.columns : [];
  const newCols = Array.isArray(newDb?.columns) ? newDb.columns : [];
  const oldByHash = new Map(oldCols.map(c => [c.col_hash, c]));
  const mappingObjs = Array.isArray(mappingEntries) ? mappingEntries.map((m) => {
    if (typeof m === 'string') {
      try { return JSON.parse(m); } catch { return null; }
    }
    return m;
  }).filter(Boolean) : [];

  const choiceByNewHash = new Map(mappingObjs.map(m => [m.new_hash, m.choice ?? m.suggested_choice ?? 'NEW']));
  const result = [];
  const namesMatch = (a, b) => (a ?? '').trim().toLowerCase() === (b ?? '').trim().toLowerCase();

  newCols.forEach((col, idx) => {
    const choice = choiceByNewHash.get(col.col_hash) ?? 'NEW';
    if (choice === 'IGNORE') return;
    if (choice !== 'NEW' && oldByHash.has(choice)) {
      const oldCol = oldByHash.get(choice);
      const merged = { ...col, col_hash: oldCol.col_hash };
      // Preserve in-app customized labels when the column name did not change; otherwise prefer the new label from the file
      const useOldLabel = namesMatch(col.col_name, oldCol.col_name);
      merged.col_label = useOldLabel
        ? (oldCol.col_label ?? col.col_label)
        : (col.col_label ?? oldCol.col_label);
      if (Array.isArray(oldCol.col_vars) && oldCol.col_vars.length) {
        // Rebuild variants when possible using stored recipes
        const baseLabel = oldCol.col_vars[0]?.var_label ?? (col.col_label ?? col.col_name ?? 'Original');
        const baseMeta = oldCol.col_vars[0]?.meta?.kind === 'original' ? oldCol.col_vars[0].meta : { kind: 'original' };
        const baseVariant = {
          var_label: baseLabel,
          col_type: merged.col_type,
          col_sep: merged.col_sep ?? (merged.col_type === 'l' ? ';' : ''),
          col_values: variants.cloneColValues ? variants.cloneColValues(merged.col_values) : merged.col_values,
          meta: baseMeta
        };
        const rebuilt = [baseVariant];
        const tempBase = { ...merged, col_vars: rebuilt };
        oldCol.col_vars.slice(1).forEach((v) => {
          const recipe = v?.meta?.recipe;
          if (recipe) {
            try {
              const newVar = variants.createVariant(tempBase, recipe);
              if (v?.var_label) {
                newVar.var_label = v.var_label;
              }
              rebuilt.push(newVar);
              tempBase.col_vars = rebuilt;
            } catch {
              rebuilt.push(v);
            }
          } else {
            rebuilt.push(v);
          }
        });
        merged.col_vars = rebuilt;
      }
      result.push(merged);
    } else {
      result.push(col);
    }
  });

  result.forEach((col, i) => { col.col_index = i + 1; });
  return { ...newDb, columns: result };
};

/**
 * Summarize each predictor optionally against a qualitative response.
 * @param {Column[]} columns
 * @param {Array<{col_hash:string,col_label:string}>} predictors
 * @param {Array<{col_hash:string,col_label:string}>} responses
 * @param {Array<Record<string, any>>} data
 * @param {Record<string,any>} options
 * @param {Set<string>} flagsUsed
 * @param {Record<string,Function>=} formatFns
 * @returns {Array<{ predictor: string, response?: string|null, predictor_type: string, response_type?: string|null, table: TableLike }>}
 */
ns.summarizePredictors = function (columns, predictors, responses, data, options, flagsUsed, formatFns = {}) {
  const response = responses.length > 0 ? responses[0] : null;
  const responseCol = response
    ? columns.find(c => c.col_hash === response.col_hash && c.col_var_index === (response.col_var_index ?? null))
      || columns.find(c => c.col_hash === response.col_hash)
    : null;
  const responseType = responseCol?.col_type || null; const responseVals = responseCol?.raw_values || null;
  const lang = normalizeLanguage(options?.lang);
  return predictors.map(pred => {
    const predictorCol = columns.find(c => c.col_hash === pred.col_hash && c.col_var_index === (pred.col_var_index ?? null))
      || columns.find(c => c.col_hash === pred.col_hash);
    if (!predictorCol) return null;
    const predictorVals = predictorCol.raw_values; const predictorType = predictorCol.col_type; const predictorSep = predictorCol.col_sep || ';'; const formatFn = formatFns[pred.col_label] || null;
    let table;
    if (!response) {
      if (predictorType === 'q') { table = ns.summarize_q(predictorVals, formatFn, options, { labels: predictorCol.col_values?.labels ?? null }); flagsUsed.add('has_q'); }
      else if (predictorType === 'l') { table = ns.summarize_l(predictorVals, predictorSep, formatFn, options); flagsUsed.add('has_l'); }
      else if (predictorType === 'n') { table = numeric.summarize_n(predictorVals, formatFn, options); flagsUsed.add('has_n'); }
    } else {
      if (predictorType === 'q' && responseType === 'q') {
        const labelOptions = { rowLabels: predictorCol.col_values?.labels ?? null, colLabels: responseCol.col_values?.labels ?? null };
        table = contingency.summarize_q_q(predictorVals, responseVals, formatFn, options, labelOptions); flagsUsed.add('has_qq');
      } else if (predictorType === 'n' && responseType === 'q') {
        table = numeric.summarize_n_q(predictorVals, responseVals, formatFn, flagsUsed, options); flagsUsed.add('has_nq');
      } else if (predictorType === 'l' && responseType === 'q') {
        const includePrefix = options?.label_list_with_column ?? true;
        const summaries = ns.summarize_l_q(predictorVals, responseVals, formatFn, options, {
          separator: predictorSep,
          predictorLabel: pred.col_label,
          responseLabel: response?.col_label || null,
          lang,
          includePrefix
        }).map(entry => ({
          predictor: entry.display_label,
          response: entry.response_label,
          predictor_type: 'q',
          response_type: responseType,
          table: entry.table
        }));
        flagsUsed.add('has_lq');
        return summaries;
      }
    }
    if (table?.used_resid_greater || table?.used_resid_lower) flagsUsed.add('has_residuals');
    return { predictor: pred.col_label, response: response?.col_label || null, predictor_type: predictorType, response_type: responseType, table };
  }).filter(Boolean).flat();
};

/**
 * End-to-end analysis from Bubble element inputs to combined analysis object.
 * @param {string[]} elementPredictors JSON strings
 * @param {string[]} elementResponses JSON strings
 * @param {Record<string,{columns:Column[]}>} dbs databases by id
 * @param {Record<string,any>} options
 * @returns {{ result: CombinedAnalysis, flags: string[] }}
 */
ns.runAnalysis = function (elementPredictors, elementResponses, dbs, options) {
  const mergedOptions = ns.getDefaultAnalysisOptions(options);
  const predictors = elementPredictors.map(JSON.parse); const responses = elementResponses.map(JSON.parse); const flagsUsed = new Set();
  const lang = mergedOptions.lang;
  const columns = predictors.concat(responses).map(col => {
    const db = dbs[col.database_id];
    if (!db) return null;
    const baseCol = ns.getColumn(db, col.col_hash);
    if (!baseCol) return null;
    const hasVariantIndex = col.col_var_index !== null && col.col_var_index !== undefined;
    const variant = hasVariantIndex && Array.isArray(baseCol.col_vars) ? baseCol.col_vars[col.col_var_index] : null;
    const effectiveColValues = variant?.col_values ?? baseCol.col_values;
    const effectiveType = variant?.col_type ?? baseCol.col_type;
    const effectiveSep = variant?.col_sep ?? baseCol.col_sep ?? ';';
    const raw_values = factors.decodeColValues(effectiveColValues, effectiveType, effectiveSep);
    return {
      col_hash: baseCol.col_hash,
      col_label: col.col_label || variant?.var_label || baseCol.col_label,
      col_type: effectiveType,
      col_sep: effectiveSep,
      col_values: effectiveColValues,
      raw_values,
      col_var_index: hasVariantIndex ? col.col_var_index : null,
      var_meta: variant?.meta ?? null
    };
  }).filter(Boolean);
  const rowwise = ns.getRowwiseData(columns);
  const result = ns.summarizePredictors(columns, predictors, responses, rowwise, mergedOptions, flagsUsed);
  const allMethods = result.map(r => r.table?.test_used).filter(Boolean);
  const symbolMap = ns.generateTestSymbolMap(allMethods, mergedOptions);
  result.forEach(r => { if (r.table?.test_used) { const method = r.table.test_used; r.table.test_symbol = symbolMap[method]; } });
  const test_legend = Object.entries(symbolMap).map(([method, symbol]) => ({ method, symbol }));
  const finalResult = { analysis: result, test_legend, lang };
  return { result: finalResult, flags: Array.from(flagsUsed) };
};

/**
 * Produce a lightweight summary for a column or one of its variants.
 * Returns `"label: summary"` pairs by default or `{ label, summary }` objects when `structured` is true.
 * @param {Column} column
 * @param {number|null} [variantIndex]
 * @param {{ lang?: string, formatFn?: Function, maxRows?: number, structured?: boolean }} [options]
 * @returns {Array<Record<string, string>> | Array<{label:string, summary:string}>}
 */
ns.describeColumn = function (column, variantIndex = null, options = {}) {
  if (!column || typeof column !== 'object') return [];
  let baseColumn = column;
  if (!baseColumn.col_hash) {
    baseColumn = { ...column, col_hash: '__temp_col_hash__' };
  }
  const colHash = baseColumn.col_hash;
  const database = { columns: [baseColumn] };
  let lookup;
  try {
    lookup = ns.getColumnValues(database, colHash, variantIndex);
  } catch (error) {
    console.warn('describeColumn: failed to decode column values.', error);
    return [];
  }
  const resolvedColumn = lookup.column || baseColumn;
  const values = Array.isArray(lookup.rawValues) ? lookup.rawValues : [];
  if (!values.length) return [];
  const variant = lookup.variant;
  const colType = variant?.col_type ?? resolvedColumn.col_type ?? 'q';
  let colSep = variant?.col_sep ?? resolvedColumn.col_sep;
  if (!colSep) colSep = colType === 'l' ? ';' : '';
  const structured = options?.structured === true;
  const lang = normalizeLanguage(options?.lang);
  const summaryOptions = { ...options, lang };
  delete summaryOptions.formatFn;
  delete summaryOptions.maxRows;
  delete summaryOptions.structured;
  const formatFn = options.formatFn ?? null;
  let table;
  try {
    if (colType === 'q') {
      const labels = variant?.col_values?.labels ?? resolvedColumn.col_values?.labels ?? null;
      table = ns.summarize_q(values, formatFn, summaryOptions, { labels });
    } else if (colType === 'l') {
      table = ns.summarize_l(values, colSep, formatFn, summaryOptions);
    } else if (colType === 'n') {
      table = numeric.summarize_n(values, formatFn, summaryOptions);
    } else {
      return [];
    }
  } catch (error) {
    console.warn('describeColumn: failed to build summary.', error);
    return [];
  }
  const columns = Array.isArray(table?.columns) && table.columns.length > 0
    ? table.columns
    : (Array.isArray(table?.rows) && table.rows[0] ? Object.keys(table.rows[0]) : []);
  const rows = Array.isArray(table?.rows) ? table.rows : [];
  if (!columns.length || !rows.length) return [];
  const maxRowsValue = Number(options?.maxRows);
  const maxRows = Number.isFinite(maxRowsValue) && maxRowsValue > 0 ? Math.floor(maxRowsValue) : null;
  const slice = maxRows ? rows.slice(0, maxRows) : rows;
  const normalizeCell = (value) => {
    if (value === null || value === undefined) return '';
    if (typeof value === 'number' && !Number.isFinite(value)) return '';
    return String(value).trim();
  };
  return slice.map((row) => {
    const columnValues = {};
    columns.forEach((colName) => {
      if (Object.prototype.hasOwnProperty.call(row, colName)) {
        columnValues[String(colName)] = normalizeCell(row[colName]);
      }
    });
    const firstColumnName = String(columns[0] ?? '');
    const label = (columnValues[firstColumnName] ?? '').trim();
    const summary = columns.slice(1)
      .map((colName) => columnValues[String(colName)] ?? '')
      .filter((value) => value && value.trim())
      .join(' | ');
    if (!label && !summary) return null;
    if (structured) {
      return { label, summary };
    }
    const formatted = (() => {
      if (label && summary) return `${label}: ${summary}`;
      if (label) return label;
      if (summary) return summary;
      return '';
    })();
    return formatted ? formatted : null;
  }).filter(Boolean);
};

/**
 * Summarize every column (and its variants) in a parsed database payload.
 * @param {{columns?: Column[]}|null|undefined} database
 * @param {{ lang?: string, formatFn?: Function, maxRows?: number, structured?: boolean }} [options]
 * @returns {Array<{ label: string, type: string, summary: Array<any>, variants: Array<{ label: string, type: string, summary: Array<any> }> }>}
 */
ns.describeDataset = function (database, options = {}) {
  if (!database || !Array.isArray(database.columns)) return [];

  return database.columns.map((column) => {
    const label = column.col_label ?? column.col_name ?? column.col_hash ?? '';
    const type = column.col_type ?? 'q';
    const summary = ns.describeColumn(column, null, options);
    const variants = Array.isArray(column.col_vars)
      ? column.col_vars.map((variant) => ({
          label: variant.var_label ?? label,
          type: variant.col_type ?? type,
          summary: ns.describeColumn(variant, null, options)
        }))
      : [];

    return { label, type, summary, variants };
  });
};

/**
 * Reorder a JSON-string list by swapping an item with its neighbor and renumbering "order".
 * @param {string[]} list JSON strings with an "order" field
 * @param {number|string} index 0-based index of the item to move
 * @param {'backward'|'forward'} direction Move direction
 * @returns {string[]} Updated list
 */
ns.reorderVariableList = function (list, index, direction) {
  const copy = list.slice();
  const idx = parseInt(index, 10);
  const dir = direction;
  if (!Array.isArray(copy) || Number.isNaN(idx) || idx < 0 || idx >= copy.length) return list;
  const targetIndex = dir === 'forward' ? idx + 1 : idx - 1;
  if (targetIndex < 0 || targetIndex >= copy.length) return list;
  const tmp = copy[idx];
  copy[idx] = copy[targetIndex];
  copy[targetIndex] = tmp;
  const updated = copy.map((item, i) => {
    try {
      const obj = JSON.parse(item);
      obj.order = i + 1;
      return JSON.stringify(obj);
    } catch (e) {
      return item;
    }
  });
  return updated;
};

export default { ...ns, ...factors, ...contingency, ...numeric, ...variants };
