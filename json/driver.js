// @ts-check
import { formatNumberLocale } from './_env.js';
import factors from './factors.js';
import contingency from './contingency.js';
import numeric from './numeric.js';
import variants from './variants.js';
import { getBinaryLabels, getDefaultMissingLabel, getTableHeaders, normalizeLanguage, translate } from '../i18n/index.js';

/**
 * @typedef {Object} Column
 * @property {string} col_hash
 * @property {string} col_label
 * @property {'q'|'n'|'l'} col_type
 * @property {string=} col_sep
 * @property {any[]=} raw_values
 * @property {{labels?: string[]}=} col_values
 */

/**
 * @typedef {{columns: string[], rows: Array<Record<string,string>>, [k:string]: any}} TableLike
 */

/**
 * @typedef {{analysis: Array<{ predictor: string, response?: string|null, predictor_type: string, response_type?: string|null, table: TableLike }>, test_legend: Array<{method:string,symbol:string}>}} CombinedAnalysis
 */

/** @type {Record<string, any>} */
const ns = {};

/**
 * Retrieve a column by hash from a parsed database payload.
 * @param {{columns?: Column[]}|null|undefined} database
 * @param {string} colHash
 * @returns {Column|null}
 */
ns.getColumn = function (database, colHash) {
  if (!database || !Array.isArray(database.columns)) return null;
  return database.columns.find((col) => col?.col_hash === colHash) ?? null;
};

/**
 * Retrieve a column by hash and decode its raw values.
 * @param {{columns?: Column[]}|null|undefined} database Parsed database payload returned by parseColumns
 * @param {string} colHash Column hash to match
 * @param {number|null} [variantIndex=null] Optional variant index from col_vars
 * @returns {{ column: Column|null, variant: any|null, rawValues: any[] }}
 */
ns.getColumnValues = function (database, colHash, variantIndex = null) {
  const column = ns.getColumn(database, colHash);
  if (!column) {
    return { column: null, variant: null, rawValues: [] };
  }
  const hasVariantIndex = variantIndex !== null && variantIndex !== undefined;
  const variant = hasVariantIndex && Array.isArray(column.col_vars)
    ? column.col_vars[variantIndex] ?? null
    : null;
  const colType = variant?.col_type ?? column.col_type ?? 'q';
  let colSep = variant?.col_sep ?? column.col_sep;
  if (!colSep) colSep = colType === 'l' ? ';' : '';
  const colValues = variant?.col_values ?? column.col_values;
  const target = variant
    ? { ...variant, col_type: colType, col_sep: colSep, col_values: colValues }
    : { ...column, col_type: colType, col_sep: colSep, col_values: colValues };
  const rawValues = factors.decodeColumn(target) || [];
  return { column, variant, rawValues };
};

/**
 * Append a variant to the specified column, seeding the base variant when needed.
 * @param {{columns?: Column[]}|null|undefined} database Parsed database payload returned by parseColumns
 * @param {string} colHash Column hash to match
 * @param {any} newVariant Variant payload generated by variants.createVariant
 * @returns {any}
 */
ns.addVariant = function (database, colHash, newVariant) {
  if (!newVariant || typeof newVariant !== 'object') {
    throw new Error('Variant payload is required to add a variant.');
  }
  if (!database || !Array.isArray(database.columns)) {
    throw new Error('Invalid database payload; expected an object with columns.');
  }
  const column = ns.getColumn(database, colHash);
  if (!column) {
    throw new Error(`Column with hash ${colHash} not found in database.`);
  }
  if (!Array.isArray(column.col_vars) || column.col_vars.length === 0) {
    const colLabel = column.col_label ?? "Original";
    const colType = column.col_type ?? 'q';
    const colSep = column.col_sep ?? (colType === 'l' ? ';' : '');
    const clone = variants.cloneColValues
      ? variants.cloneColValues(column.col_values)
      : (column.col_values ? JSON.parse(JSON.stringify(column.col_values)) : column.col_values);
    column.col_vars = [{
      var_label: colLabel,
      col_type: colType,
      col_sep: colSep,
      col_values: clone,
      meta: { kind: 'original' }
    }];
  }
  column.col_vars.push(newVariant);
  return newVariant;
};

/**
 * Build row-wise objects from column-major raw_values.
 * @param {Column[]} columns
 * @returns {Array<Record<string, any>>}
 */
ns.getRowwiseData = function (columns) {
  if (!Array.isArray(columns)) return [];
  const n = Math.max(...columns.map(c => c.raw_values?.length || 0));
  const rows = [];
  for (let i = 0; i < n; i++) { const row = {}; columns.forEach(col => { row[col.col_hash] = col.raw_values?.[i] ?? null; }); rows.push(row); }
  return rows;
};

/**
 * Convert named-row objects into a 2D matrix following provided column order.
 * @param {string[]} columns
 * @param {Array<Record<string, any>>} rows
 * @returns {any[][]}
 */
ns.tabularRowsToMatrix = function (columns, rows) { return rows.map(row => columns.map(col => row[col])); };

/**
 * Frequency table for qualitative values.
 * @param {Array<string|null|undefined>} values
 * @param {(ctx:{count:number,percent:number,total:number})=>string=} formatFn
 * @param {{missing_label?:string, include_missing?:boolean, lang?:string}=} options
 * @param {{labels?: string[]|null}=} param3
 * @returns {TableLike}
 */
ns.summarize_q = function (values, formatFn = null, options = {}, { labels = null } = {}) {
  const freqMap = {}; let missingCount = 0; const total = values.length;
  const lang = normalizeLanguage(options?.lang);
  const missingLabel = options?.missing_label ?? getDefaultMissingLabel(lang);
  const includeMissing = options?.include_missing ?? true;
  const [variableHeader, descriptionHeader] = getTableHeaders(lang);
  values.forEach(val => { const v = val?.toString().trim(); if (!v) { missingCount++; return; } freqMap[v] = (freqMap[v] || 0) + 1; });
  const sortedLabels = labels ?? Object.keys(freqMap).sort();
  const rows = sortedLabels.map(label => { const count = freqMap[label] || 0; const percent = (count / total) * 100; const percentFormatted = formatNumberLocale(percent, 1, lang); const cell = formatFn ? formatFn({ count, percent, total }) : `${count} (${percentFormatted}%)`; return { [variableHeader]: label, [descriptionHeader]: cell }; });
  if (includeMissing && missingCount > 0) { const percent = (missingCount / total) * 100; const percentFormatted = formatNumberLocale(percent, 1, lang); const cell = formatFn ? formatFn({ count: missingCount, percent, total }) : `${missingCount} (${percentFormatted}%)`; rows.push({ [variableHeader]: missingLabel, [descriptionHeader]: cell }); }
  return { columns: [variableHeader, descriptionHeader], rows, summary: { total, total_is_full: true }, lang };
};

/**
 * Frequency table for list-like qualitative values (split by a separator).
 * @param {Array<string|null|undefined>} values
 * @param {string=} sep
 * @param {(ctx:{count:number,percent:number,total:number})=>string=} formatFn
 * @param {{missing_label?: string, include_missing?: boolean, lang?: string}=} options
 * @returns {TableLike}
 */
ns.summarize_l = function (values, sep = ';', formatFn = null, options = {}) {
  if (!Array.isArray(values)) return { columns: [], rows: [], summary: { total: 0, total_is_full: true } };
  const counts = {}; let missingCount = 0; const total = values.length;
  const lang = normalizeLanguage(options?.lang);
  const missingLabel = options?.missing_label ?? getDefaultMissingLabel(lang);
  const includeMissing = options?.include_missing ?? true;
  const [variableHeader, descriptionHeader] = getTableHeaders(lang);
  values.forEach(v => { if (!v?.trim()) { missingCount++; return; } const items = v.split(sep).map(s => s.trim()).filter(Boolean); if (items.length === 0) { missingCount++; return; } items.forEach(item => { counts[item] = (counts[item] || 0) + 1; }); });
  const rows = Object.entries(counts).sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0])).map(([level, count]) => { const percent = (count / total) * 100; const percentFormatted = formatNumberLocale(percent, 1, lang); const cell = formatFn ? formatFn({ count, percent, total }) : `${count} (${percentFormatted}%)`; return { [variableHeader]: level, [descriptionHeader]: cell }; });
  if (includeMissing && missingCount > 0) { const percent = (missingCount / total) * 100; const percentFormatted = formatNumberLocale(percent, 1, lang); const cell = formatFn ? formatFn({ count: missingCount, percent, total }) : `${missingCount} (${percentFormatted}%)`; rows.push({ [variableHeader]: missingLabel, [descriptionHeader]: cell }); }
  return { columns: [variableHeader, descriptionHeader], rows, summary: { total, total_is_full: true }, lang };
};

/**
 * Build a map of statistical test methods to display symbols.
 * @param {string[]} methods
 * @param {{symbol_style?: 'numeric'|'alpha'}=} options
 * @returns {Record<string,string>}
 */
ns.generateTestSymbolMap = function (methods, options) {
  const style = options?.symbol_style ?? 'numeric'; const uniqueMethods = [...new Set(methods)];
  const numericSym = ['¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹', '¹⁰']; const alpha = ['ᵃ', 'ᵇ', 'ᶜ', 'ᵈ', 'ᵉ', 'ᶠ', 'ᵍ', 'ʰ', 'ᶦ', 'ʲ'];
  const base = (style === 'alpha' ? alpha : numericSym); const map = {}; uniqueMethods.forEach((method, i) => { map[method] = base[i] || `(${i + 1})`; }); return map;
};


/**
 * Merge caller options with the defaults that Statz uses during runAnalysis.
 * @param {Record<string, any>=} options
 * @returns {Record<string, any>}
 */
ns.getDefaultAnalysisOptions = function (options = {}) {
  const lang = normalizeLanguage(options?.lang);
  const normalized = { ...options, lang };

  const alphaValue = Number(normalized.alpha);
  normalized.symbol_style = normalized.symbol_style ?? 'numeric';
  normalized.alpha = Number.isFinite(alphaValue) ? alphaValue : 0.05;

  const statOptions = Array.isArray(normalized.stat_options) && normalized.stat_options.length
    ? normalized.stat_options.slice()
    : ['mean_sd'];
  normalized.stat_options = statOptions;

  normalized.percent_by = normalized.percent_by === 'col' ? 'col' : 'row';
  normalized.adjust_kruskal = normalized.adjust_kruskal ?? 'bonferroni';
  normalized.include_missing = normalized.include_missing ?? true;
  normalized.missing_label = normalized.missing_label ?? getDefaultMissingLabel(lang);

  const residuals = normalized.residual_symbols ?? {};
  normalized.residual_symbols = {
    greater: residuals.greater ?? translate('table.legends.residualGreaterSymbol', lang),
    lower: residuals.lower ?? translate('table.legends.residualLowerSymbol', lang)
  };

  const binaryLabels = getBinaryLabels(lang);
  normalized.yes_label = normalized.yes_label ?? binaryLabels.yes;
  normalized.no_label = normalized.no_label ?? binaryLabels.no;

  const minCount = Number(normalized.binary_min_count);
  normalized.binary_min_count = Number.isFinite(minCount) && minCount > 0 ? Math.floor(minCount) : 1;

  return normalized;
};
/**
 * Summarize each predictor optionally against a qualitative response.
 * @param {Column[]} columns
 * @param {Array<{col_hash:string,col_label:string}>} predictors
 * @param {Array<{col_hash:string,col_label:string}>} responses
 * @param {Array<Record<string, any>>} data
 * @param {Record<string,any>} options
 * @param {Set<string>} flagsUsed
 * @param {Record<string,Function>=} formatFns
 * @returns {Array<{ predictor: string, response?: string|null, predictor_type: string, response_type?: string|null, table: TableLike }>}
 */
ns.summarizePredictors = function (columns, predictors, responses, data, options, flagsUsed, formatFns = {}) {
  const response = responses.length > 0 ? responses[0] : null;
  const responseCol = response ? columns.find(c => c.col_hash === response.col_hash) : null;
  const responseType = responseCol?.col_type || null; const responseVals = responseCol?.raw_values || null;
  const lang = normalizeLanguage(options?.lang);
  return predictors.map(pred => {
    const predictorCol = columns.find(c => c.col_hash === pred.col_hash); if (!predictorCol) return null;
    const predictorVals = predictorCol.raw_values; const predictorType = predictorCol.col_type; const predictorSep = predictorCol.col_sep || ';'; const formatFn = formatFns[pred.col_label] || null;
    let table;
    if (!response) {
      if (predictorType === 'q') { table = ns.summarize_q(predictorVals, formatFn, options, { labels: predictorCol.col_values?.labels ?? null }); flagsUsed.add('has_q'); }
      else if (predictorType === 'l') { table = ns.summarize_l(predictorVals, predictorSep, formatFn, options); flagsUsed.add('has_l'); }
      else if (predictorType === 'n') { table = numeric.summarize_n(predictorVals, formatFn, options); flagsUsed.add('has_n'); }
    } else {
      if (predictorType === 'q' && responseType === 'q') {
        const labelOptions = { rowLabels: predictorCol.col_values?.labels ?? null, colLabels: responseCol.col_values?.labels ?? null };
        table = contingency.summarize_q_q(predictorVals, responseVals, formatFn, options, labelOptions); flagsUsed.add('has_qq');
      } else if (predictorType === 'n' && responseType === 'q') {
        table = numeric.summarize_n_q(predictorVals, responseVals, formatFn, flagsUsed, options); flagsUsed.add('has_nq');
      } else if (predictorType === 'l' && responseType === 'q') {
        const binCols = numeric.decomposeListAsBinaryCols(predictorVals, predictorSep, options);
        const summaries = Object.entries(binCols).flatMap(([label, binVals]) => {
          try { const table = contingency.summarize_q_q(binVals, responseVals, formatFn, options); return [{ predictor: `${pred.col_label.replace(/[\s\p{P}]+$/u, '')}: ${label}`, response: response?.col_label || null, predictor_type: 'q', response_type: responseType, table }]; }
          catch (e) { const warnMessage = translate('warnings.summarizeFailure', lang, { label, context: pred.col_label }); console.warn(`${warnMessage}:`, e.message); return []; }
        });
        flagsUsed.add('has_lq');
        return summaries;
      }
    }
    if (table?.used_resid_greater || table?.used_resid_lower) flagsUsed.add('has_residuals');
    return { predictor: pred.col_label, response: response?.col_label || null, predictor_type: predictorType, response_type: responseType, table };
  }).filter(Boolean).flat();
};

/**
 * End-to-end analysis from Bubble element inputs to combined analysis object.
 * @param {string[]} elementPredictors JSON strings
 * @param {string[]} elementResponses JSON strings
 * @param {Record<string,{columns:Column[]}>} dbs databases by id
 * @param {Record<string,any>} options
 * @returns {{ result: CombinedAnalysis, flags: string[] }}
 */
ns.runAnalysis = function (elementPredictors, elementResponses, dbs, options) {
  const mergedOptions = ns.getDefaultAnalysisOptions(options);
  const predictors = elementPredictors.map(JSON.parse); const responses = elementResponses.map(JSON.parse); const flagsUsed = new Set();
  const lang = mergedOptions.lang;
  const columns = predictors.concat(responses).map(col => {
    const db = dbs[col.database_id];
    if (!db) return null;
    const baseCol = ns.getColumn(db, col.col_hash);
    if (!baseCol) return null;
    const hasVariantIndex = col.col_var_index !== null && col.col_var_index !== undefined;
    const variant = hasVariantIndex && Array.isArray(baseCol.col_vars) ? baseCol.col_vars[col.col_var_index] : null;
    const effectiveColValues = variant?.col_values ?? baseCol.col_values;
    const effectiveType = variant?.col_type ?? baseCol.col_type;
    const effectiveSep = variant?.col_sep ?? baseCol.col_sep ?? ';';
    const raw_values = factors.decodeColValues(effectiveColValues, effectiveType, effectiveSep);
    return {
      col_hash: baseCol.col_hash,
      col_label: col.col_label || variant?.var_label || baseCol.col_label,
      col_type: effectiveType,
      col_sep: effectiveSep,
      col_values: effectiveColValues,
      raw_values,
      col_var_index: hasVariantIndex ? col.col_var_index : null,
      var_meta: variant?.meta ?? null
    };
  }).filter(Boolean);
  const rowwise = ns.getRowwiseData(columns);
  const result = ns.summarizePredictors(columns, predictors, responses, rowwise, mergedOptions, flagsUsed);
  const allMethods = result.map(r => r.table?.test_used).filter(Boolean);
  const symbolMap = ns.generateTestSymbolMap(allMethods, mergedOptions);
  result.forEach(r => { if (r.table?.test_used) { const method = r.table.test_used; r.table.test_symbol = symbolMap[method]; } });
  const test_legend = Object.entries(symbolMap).map(([method, symbol]) => ({ method, symbol }));
  const finalResult = { analysis: result, test_legend, lang };
  return { result: finalResult, flags: Array.from(flagsUsed) };
};

/**
 * Produce a lightweight summary for a column or one of its variants.
 * Returns `"label: summary"` pairs by default or `{ label, summary }` objects when `structured` is true.
 * @param {Column} column
 * @param {number|null} [variantIndex]
 * @param {{ lang?: string, formatFn?: Function, maxRows?: number, structured?: boolean }} [options]
 * @returns {Array<Record<string, string>> | Array<{label:string, summary:string}>}
 */
ns.describeColumn = function (column, variantIndex = null, options = {}) {
  if (!column || typeof column !== 'object') return [];
  let baseColumn = column;
  if (!baseColumn.col_hash) {
    baseColumn = { ...column, col_hash: '__temp_col_hash__' };
  }
  const colHash = baseColumn.col_hash;
  const database = { columns: [baseColumn] };
  let lookup;
  try {
    lookup = ns.getColumnValues(database, colHash, variantIndex);
  } catch (error) {
    console.warn('describeColumn: failed to decode column values.', error);
    return [];
  }
  const resolvedColumn = lookup.column || baseColumn;
  const values = Array.isArray(lookup.rawValues) ? lookup.rawValues : [];
  if (!values.length) return [];
  const variant = lookup.variant;
  const colType = variant?.col_type ?? resolvedColumn.col_type ?? 'q';
  let colSep = variant?.col_sep ?? resolvedColumn.col_sep;
  if (!colSep) colSep = colType === 'l' ? ';' : '';
  const structured = options?.structured === true;
  const lang = normalizeLanguage(options?.lang);
  const summaryOptions = { ...options, lang };
  delete summaryOptions.formatFn;
  delete summaryOptions.maxRows;
  delete summaryOptions.structured;
  const formatFn = options.formatFn ?? null;
  let table;
  try {
    if (colType === 'q') {
      const labels = variant?.col_values?.labels ?? resolvedColumn.col_values?.labels ?? null;
      table = ns.summarize_q(values, formatFn, summaryOptions, { labels });
    } else if (colType === 'l') {
      table = ns.summarize_l(values, colSep, formatFn, summaryOptions);
    } else if (colType === 'n') {
      table = numeric.summarize_n(values, formatFn, summaryOptions);
    } else {
      return [];
    }
  } catch (error) {
    console.warn('describeColumn: failed to build summary.', error);
    return [];
  }
  const columns = Array.isArray(table?.columns) && table.columns.length > 0
    ? table.columns
    : (Array.isArray(table?.rows) && table.rows[0] ? Object.keys(table.rows[0]) : []);
  const rows = Array.isArray(table?.rows) ? table.rows : [];
  if (!columns.length || !rows.length) return [];
  const maxRowsValue = Number(options?.maxRows);
  const maxRows = Number.isFinite(maxRowsValue) && maxRowsValue > 0 ? Math.floor(maxRowsValue) : null;
  const slice = maxRows ? rows.slice(0, maxRows) : rows;
  const normalizeCell = (value) => {
    if (value === null || value === undefined) return '';
    if (typeof value === 'number' && !Number.isFinite(value)) return '';
    return String(value).trim();
  };
  return slice.map((row) => {
    const columnValues = {};
    columns.forEach((colName) => {
      if (Object.prototype.hasOwnProperty.call(row, colName)) {
        columnValues[String(colName)] = normalizeCell(row[colName]);
      }
    });
    const firstColumnName = String(columns[0] ?? '');
    const label = (columnValues[firstColumnName] ?? '').trim();
    const summary = columns.slice(1)
      .map((colName) => columnValues[String(colName)] ?? '')
      .filter((value) => value && value.trim())
      .join(' | ');
    if (!label && !summary) return null;
    if (structured) {
      return { label, summary };
    }
    const formatted = (() => {
      if (label && summary) return `${label}: ${summary}`;
      if (label) return label;
      if (summary) return summary;
      return '';
    })();
    return formatted ? formatted : null;
  }).filter(Boolean);
};

/**
 * Reorder a JSON-string list by swapping an item with its neighbor and renumbering "order".
 * @param {string[]} list JSON strings with an "order" field
 * @param {number|string} index 0-based index of the item to move
 * @param {'backward'|'forward'} direction Move direction
 * @returns {string[]} Updated list
 */
ns.reorderVariableList = function (list, index, direction) {
  const copy = list.slice();
  const idx = parseInt(index, 10);
  const dir = direction;
  if (!Array.isArray(copy) || Number.isNaN(idx) || idx < 0 || idx >= copy.length) return list;
  const targetIndex = dir === 'forward' ? idx + 1 : idx - 1;
  if (targetIndex < 0 || targetIndex >= copy.length) return list;
  const tmp = copy[idx];
  copy[idx] = copy[targetIndex];
  copy[targetIndex] = tmp;
  const updated = copy.map((item, i) => {
    try {
      const obj = JSON.parse(item);
      obj.order = i + 1;
      return JSON.stringify(obj);
    } catch (e) {
      return item;
    }
  });
  return updated;
};

export default { ...ns, ...factors, ...contingency, ...numeric, ...variants };
